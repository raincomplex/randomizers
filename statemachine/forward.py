'''
https://en.wikipedia.org/wiki/Forward_algorithm
https://web.stanford.edu/~jurafsky/slp3/ -- Speech and Language Processing, appendix chapter A. Hidden Markov Models
'''
import util, math, random

def forward(machine, seq, col=None):
    'return log_2(probability that seq is generated by machine)'
    # we need to eliminate any noncyclic states so that we can reverse the machine cleanly
    machine = util.prune(machine)
    comefrom = util.reverse(machine)

    if col is None:
        col = getsteady(machine)
    
    tpcache = {}  # {(sp, s, c): prob}

    exp = 0
    for c in seq:
        new = {}
        for s in machine:
            t = 0
            for sp in comefrom[s]:
                prob = tpcache.get((sp, s, c))
                if prob is None:
                    prob = machine[sp].get((c, s), 0) / sum(machine[sp].values())
                    tpcache[sp, s, c] = prob
                t += col[sp] * prob
            new[s] = t
        col = new

        # normalize to keep exponents within floating point range
        m = max(col.values())
        if m == 0:
            break  # can't be in any state
        exp += math.log(m, 2)
        col = {s: prob / m for s, prob in col.items()}

    s = sum(col.values())
    if s == 0:
        return -math.inf
    return exp + math.log(s, 2)

def getsteady(machine):
    comefrom = util.reverse(machine)
    
    probs = [random.random() for s in machine]
    total = sum(probs)
    col = {s: probs.pop(0) / total for s in machine}
    #col = {s: 1/len(machine) for s in machine}
    
    tpcache = {}  # {(sp, s): prob}
    maxdist = 1
    itercount = 100
    while maxdist > 1e-10 and itercount > 0:
        new = {}
        for s in machine:
            t = 0
            for sp in comefrom[s]:
                prob = tpcache.get((sp, s))
                if prob is None:
                    prob = 0
                    total = sum(machine[sp].values())
                    for c in 'jiltsoz':
                        prob += machine[sp].get((c, s), 0)
                    prob /= total
                    tpcache[sp, s] = prob
                t += col[sp] * prob
            new[s] = t
        maxdist = max(abs(new[s] - col[s]) for s in machine)
        last = col
        col = new
        itercount -= 1
    '''
    print(maxdist, itercount)
    if len(machine) == 8:
        print(last)
        print(col)
    #'''
    return col
